seed|urls|keywords|description|headers|text
https://launchschool.com/books/ruby/read/files|["http://ruby-doc.org/core-2.1.2/IO.html#method-c-new-label-IO+Open+Mode", "http://ruby-doc.org/core-2.1.2/Dir.html", "http://www.ruby-doc.org/stdlib-2.1.2/libdoc/pathname/rdoc/Pathname.html", "http://msdn.microsoft.com/en-us/library/dd911037(v=office.12).aspx", "http://ruby-doc.org/stdlib-2.1.2/libdoc/csv/rdoc/index.html", "http://json.org", "http://nokogiri.org"]|0|How to work with files in Ruby. How to work with csv, xml and json files in Ruby.|["\n\n", "\nLaunchSchool: An online school for developers\n", "Table of Contents", "Files", "What is a File?", "Creating a file", " Opening Files", "Deleting A File", "Exercise 1", "Overview of File Classes", "Exercise 2", "Working with file formats - CSV, Excel, JSON, XML", "Summary", "Open File For Reading", "Open File For Writing", "CSV and XLS/XLSX", "JSON and XML/HTML", "Exercise"]|A File represents digital information that exists on durable storage Up till now the Ruby code weve worked through has helped us express data in memory but after closing irb the variables and objects go away Files are different Files can exist before and after a program runs Files can also be shared and validated to formats that have nothing in common with one another more on this later If youve worked with a word processing application or any application in general before then youll know the flow for creating files This generally involves navigating to the File menu then selecting New File or using any other combination of keyboard shortcuts to accomplish this task In this chapter we will create open and edit files using Ruby We will look at how Files fit into the grand scheme of programming and look at examples using common formats JSON CSV XMLHTML and XLS To create a file in Ruby we pass the name of the file and the mode we want to assign to Filenew Fire up irb if you havent already and enter the following In the above example we created a new file with name simplefiletxt and mode w for read and write access to the file The Ruby IO Docs contain an extensive list of modes and options Note that the file will be created in the directory from which irb was opened On the second line we are closing the file We want to always close files Open files will continue to occupy space in memory It would be like leaving the water running and flooding your basement This can have serious impact on system performance and safety We open an existing file using Fileopen We will pass the file name and a second argument which will decide how the file will be opened Usually the following are used Reading file contents is easy in Ruby Here are two options Lets make something useful by adding content to simplefiletxt Note that in most programming languages including Ruby the flow for working with files is openuseclose We can use write or puts to write files The subtle difference between the two being puts adds a line break to the end of strings while write does not We mentioned before that its very important to always close files To help us with this Ruby will automagically close the file if the open method is called with a block Lets see how it works with write We first open the file with the w option and invoke a block that writes the contents we specify to the file This way of doing things makes sure the file closes at the end of the block Alternatively we could open the file write to it and finally close it Lets see how that works with puts Finally lets insert more text into simplefiletxt In this example we open the file for reading and updating with a mode declare a variable file as a placeholder for the file and append more text to it with the shovel operator Note that the file is automatically closed after the operation the end of the block and we can use puts or write in place of There comes a time when a file is not needed in which case we want to delete it We can do that by passing the name or reference to a file we want to delete to Filedelete Lets see it in action Be careful this command can be dangerous as it totally deletes the file from your file system Lets take one files contents as input and create a new transformed file as a result Files are everywhere As programmers we are responsible for plenty of files and that is an understatement Files rule everything Some of these files make up our programs and others will be the inputs and outputs of the programs we work on You might be thinking there are thousands of completely different applications that use files how do they all work A catch all answer would be It all comes down to the right stuff being in the right kind of files in the right place We have already touched on getting the right stuff in files Those examples are above When we are talking about the right kind of files we mean the type of the file referred to as the files Format or Extension Being in the right place means it is located in a recognizable directory structure or Path In Ruby the File class is a subclass of IO a class responsible for representing bidirectional streams Some famous IO streams you might be familiar with include STDOUT STDIN and STDERR which stand for standard output standard input and standard error respectively Test it yourself In irb type When we talk about files we are always referring to them in the context of their place in the file structure Ruby offers us a few classes to interface with files and the file system In addition to the File class that weve already looked at theres Dir which is an interface for manipulating directories and their contents Another class that is helpful in linking files and directories is Pathname Read up on these classes here Dir Dir shares some of Files methods However it is not an IO stream PathnameThe Pathname class exposes pretty much all of the methods of File and Dir The advantage to using Pathname is you can declare an instance of it and access the class methods of File and Dir on the instance object Note Depending on your particular Ruby installation you may need to require Pathname before you can use it We have included this in the example just in case If the return value from the require statement is false that just means that Pathname was already available In the example above we create a file instance and then use an instance of Pathname to find the extension We see this is equal to calling the Fileextname method Lets look at the current directory and report the files that have txt extensions We can also do this using the Pathname class We have to require pathname before using it Heres an example As you probably know its very common for software applications to handle manipulating files In order for applications to save and parse complex information it needs to work with file formats beyond just plain text Some common formats in business software and modern web applications include CSV JSON XML HTML and XLS This section will define these formats show how to work with them in Ruby and conclude with an example These are two formats that are typically used for importing and exporting tabular data commonly found in spreadsheet applications XLS refers to Microsofts Excel format For the purposes of this example we will just focus on the simple spreadsheets and not advanced features like charts formulas and cell styling Ruby does not have any core or standard support for Microsofts Excel file format Thankfully there are a few active open source projects that have brought the XLS format to Ruby The one we will use in this example is called axlsx CSV stands for Comma Separated Values If CSV was an ice cream it would be vanilla Each data cell is separated by a comma or semicolon and each line is a row of tabular data The Ruby Stdlib does support csv files with the builtin CSV class Some data doesnt fit into a box For plain text JSON and XML are data formats that let us describe the nested characteristics of data JSON stands for JavaScript Object Notation Shortly we will be looking at an example that deals with an article The article will have three fields title link and summary In JSON a newspaper and an article might be represented like this JSON is commonly compared to a hash because of its keyvalue pairs but keep in mind that JSON is unlike a hash in that it is a file format A JSON file needs to be parsed and converted into an actual Ruby hash Fortunately the Ruby standard library supports json and well see shortly how to work with JSON files XML stands for Extensible Markup Language XML is a tool for defining domain specific schematics If you are reading this book then you have just experienced at least one XML example Web pages are constructed using HTML a standardized format of XML for describing elements on the web page In XML our example above might look like this Theres a very good open source gem for parsing XML files and web pages Its called Nokogiri and we will be using it in the following exercise To wrap up this chapter we are going to work through an exercise that will show us how to interact with these common file types We will pull two files which contain articles originally gathered from feedzilla and slashdot One in XML format One in JSON We will combine the two lists to a common format sort them and save them to CSV and XLS files Lets get started In your command line run these two commands You should have two new files in your directory now The above commands saved feedzillajson and slashdotxml into your directory Get a good look at these files From the command line lets install the AXLSX gem for our XLS file and nogokiri for parsing XML First install axlsx gem After that installs install nokogiri gem Great now open irb Lets first write some code to open the slashdotxml file and get its articles title url and summary First we will require the libraries to deal with our mix of file types that we will use throughout this example Type the following into irb If you get an error it probably means one of the gems didnt install correctly Make sure the gem install instructions above successfully installed the required gems Time to open up that XML file find the item elements and parse them with Nokogiri At this point the slashdotarticles array should be populated with the articles from the slashdot XML RSS feed We have an array of hashes with fields we want to export We found all the articles with the doccssitem call and then chained it through the map block to pull out the fields we want to export We are ready to do a similar maneuver on the feedzillajson file As you can see we pulled out the articles from the feedzilla json file just like we did to the slashdot xml feed After that we sorted the combined results based on the title That just leaves us the task of writing the two export files To fully understand the examples above requires studying the various libraries we were using and thats beyond the scope of this chapter The main idea here is to show you how easy it is to work with various file types given that you study the documentation on how to work with those file types There we have it We selected data with two different formats parsed the files and built a common format sorted the data and then exported to CSV and XLS files We now have insight into what files are and can see their importance The next time we play a tune on a computer or mobile device we will understand and be thankful the program knows to play a music file not a sales report file We have had a chance to see the basic OpenUseClose workflow for files in action using Ruby and understand the importance of closing all files we open This chapter is a good reference for seeing file import and export tasks in action We demystified how some File Import Export and file system tasks can be handled by Rubys File class and close relatives Dir and Pathname We did not cover it in detail but depending on the kind of system you are working on your ability to read and write files might be affected by your file system privileges and permissions If you are not able to read or write files while working through these tasks double check that you have permissions to create to and read from file system
